/*
 * Copyright 2014,2017 International Business Machines
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __tlx_interface_t_h__
#define __tlx_interface_t_h__ 1

#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>

// Choose ONE to define what TLX support level will be
#define TLX3 1

// this is the size of the transimit and receive buffers in the afu_event
// it needs to be large enough to transmit/receive the maximum size of legally concurrent events
// for example from tlx to afu this might be response, dma completion, and buffer write.
// we'll set it at 512 for now and see if we can come up with the correct value later
#define TLX_BUFFER_SIZE 512

#ifdef TLX3
#define PROTOCOL_PRIMARY 3
#define PROTOCOL_SECONDARY 0000
#define PROTOCOL_TERTIARY 0
#endif /* TLX3 */

/* Select # of DMA interfaces, per config options in CH 17 of workbook */
#define TLX_DMA_A_SUPPORT 1
#define TLX_DMA_B_SUPPORT 0
#define MAX_DMA0_RD_CREDITS 8
#define MAX_DMA0_WR_CREDITS 8

/* Return codes for interface functions */

#define TLX_SUCCESS 0
#define TLX_DOUBLE_COMMAND 1	/* A command has been issued
				   before the preceeding
				   command of the same type has
				   been acknowledged */
#define TLX_DOUBLE_DMA0_REQ 2
#define TLX_NO_DMA_PORT_CREDITS 3

#define TLX_MMIO_ACK_NOT_VALID 4	/* Read data from previos MMIO
					   read is not available */
#define TLX_BUFFER_READ_DATA_NOT_VALID 8	/* Read data from previous
						   buffer read is not
						   available */
#define TLX_COMMAND_NOT_VALID 32	/* There is no TLX command
					   available */
#define TLX_BAD_SOCKET 16	/* The socket connection could
				   not be established */
#define TLX_VERSION_ERROR 48	/* The TLX versions in use on local & remote do not match */
#define TLX_TRANSMISSION_ERROR 64	/* There was an error sending
					   data across the socket
					   interface */
#define TLX_CLOSE_ERROR 128	/* There was an error closing
				   the socket */
#define TLX_AUX2_NOT_VALID 256	/* There auxilliary signals
				   have not changed */

/* Job Control Codes */

#define TLX_JOB_START 0x90
#define TLX_JOB_RESET 0x80
#define TLX_JOB_LLCMD 0x45
#define TLX_JOB_TIMEBASE 0x42

/* LLCMD decode */

#define TLX_LLCMD_MASK 0xFFFF000000000000LL
#define TLX_LLCMD_TERMINATE 0x0001000000000000LL
#define TLX_LLCMD_REMOVE 0x0002000000000000LL
#define TLX_LLCMD_ADD 0x0005000000000000LL
#define TLX_LLCMD_CONTEXT_MASK 0x000000000000FFFFLL

/* Response codes for TLX responses */

#define TLX_RESPONSE_DONE 0
#define TLX_RESPONSE_AERROR 1
#define TLX_RESPONSE_DERROR 3
#define TLX_RESPONSE_NLOCK 4
#define TLX_RESPONSE_NRES 5
#define TLX_RESPONSE_FLUSHED 6
#define TLX_RESPONSE_FAULT 7
#define TLX_RESPONSE_FAILED 8
#define TLX_RESPONSE_PAGED 10
#define TLX_RESPONSE_CONTEXT 11
#define TLX_RESPONSE_COMP_EQ 12
#define TLX_RESPONSE_COMP_NEQ 13
#define TLX_RESPONSE_CAS_INV 14

/* Command codes for AFU commands */

#define TLX_COMMAND_READ_CL_NA   0x0A00
#define TLX_COMMAND_READ_CL_S    0x0A50
#define TLX_COMMAND_READ_CL_M    0x0A60
#define TLX_COMMAND_READ_CL_LCK  0x0A6B
#define TLX_COMMAND_READ_CL_RES  0x0A67
#define TLX_COMMAND_READ_PE      0x0A52
#define TLX_COMMAND_READ_PNA     0x0E00
#define TLX_COMMAND_TOUCH_I      0x0240
#define TLX_COMMAND_TOUCH_S      0x0250
#define TLX_COMMAND_TOUCH_M      0x0260
#define TLX_COMMAND_WRITE_MI     0x0D60
#define TLX_COMMAND_WRITE_MS     0x0D70
#define TLX_COMMAND_WRITE_UNLOCK 0x0D6B
#define TLX_COMMAND_WRITE_C      0x0D67
#define TLX_COMMAND_WRITE_NA     0x0D00
#define TLX_COMMAND_WRITE_INJ    0x0D10
#define TLX_COMMAND_PUSH_I       0x0140
#define TLX_COMMAND_PUSH_S       0x0150
#define TLX_COMMAND_EVICT_I      0x1140
#define TLX_COMMAND_FLUSH        0x0100
#define TLX_COMMAND_INTREQ       0x0000
#define TLX_COMMAND_LOCK         0x016B
#define TLX_COMMAND_UNLOCK       0x017B
#define TLX_COMMAND_RESTART      0x0001
#define TLX_COMMAND_ZERO_M	 0x1260
#define TLX_COMMAND_CAS_E_4B	 0x0180
#define TLX_COMMAND_CAS_NE_4B	 0x0181
#define TLX_COMMAND_CAS_U_4B	 0x0182
#define TLX_COMMAND_CAS_E_8B	 0x0183
#define TLX_COMMAND_CAS_NE_8B	 0x0184
#define TLX_COMMAND_CAS_U_8B	 0x0185
#define TLX_COMMAND_ASBNOT	 0x0103
#define TLX_COMMAND_XLAT_RD_P0	 0x1F00
#define TLX_COMMAND_XLAT_RD_P0_00	 0x1F20
#define TLX_COMMAND_XLAT_RD_P0_01	 0x1F21
#define TLX_COMMAND_XLAT_RD_P0_02	0x1F22
#define TLX_COMMAND_XLAT_RD_P0_03	0x1F23
#define TLX_COMMAND_XLAT_RD_P0_04	0x1F24
#define TLX_COMMAND_XLAT_RD_P0_05	0x1F25
#define TLX_COMMAND_XLAT_RD_P0_06	0x1F26
#define TLX_COMMAND_XLAT_RD_P0_07	0x1F27
#define TLX_COMMAND_XLAT_RD_P0_08	0x1F28
#define TLX_COMMAND_XLAT_RD_P0_10	0x1F30
#define TLX_COMMAND_XLAT_RD_P0_11	0x1F31
#define TLX_COMMAND_XLAT_RD_P0_18	0x1F38
#define TLX_COMMAND_XLAT_RD_P0_19	0x1F39
#define TLX_COMMAND_XLAT_RD_P0_1C	0x1F3C
#define TLX_COMMAND_XLAT_WR_P0	 0x1F01
#define TLX_COMMAND_XLAT_WR_P0_20	0x1F40
#define TLX_COMMAND_XLAT_WR_P0_21	0x1F41
#define TLX_COMMAND_XLAT_WR_P0_22	0x1F42
#define TLX_COMMAND_XLAT_WR_P0_23	0x1F43
#define TLX_COMMAND_XLAT_WR_P0_24	0x1F44
#define TLX_COMMAND_XLAT_WR_P0_25	0x1F45
#define TLX_COMMAND_XLAT_WR_P0_26	0x1F46
#define TLX_COMMAND_XLAT_WR_P0_27	0x1F47
#define TLX_COMMAND_XLAT_WR_P0_38	0x1F58
#define TLX_COMMAND_XLAT_RD_P1	 0x1F08
#define TLX_COMMAND_XLAT_WR_P1	 0x1F09
#define TLX_COMMAND_ITAG_ABRT_RD 0x1F02
#define TLX_COMMAND_ITAG_ABRT_WR 0x1F03
#define TLX_COMMAND_XLAT_RD_TOUCH 0x1F10
#define TLX_COMMAND_XLAT_WR_TOUCH 0x1F11
#define AMO_ARMWF_ADD	 0x00
#define AMO_ARMWF_XOR	 0x01
#define AMO_ARMWF_OR	 0x02
#define AMO_ARMWF_AND	 0x03
#define AMO_ARMWF_CAS_MAX_U	 0x04
#define AMO_ARMWF_CAS_MAX_S	 0x05
#define AMO_ARMWF_CAS_MIN_U	 0x06
#define AMO_ARMWF_CAS_MIN_S	 0x07
#define AMO_ARMWF_CAS_U	 0x08
#define AMO_ARMWF_CAS_E	 0x11
#define AMO_ARMWF_CAS_NE	 0x10
#define AMO_ARMWF_INC_B	 0x18
#define AMO_ARMWF_INC_E	 0x19
#define AMO_ARMWF_DEC_B	 0x1c
#define AMO_ARMW_ADD	 0x20
#define AMO_ARMW_XOR	 0x21
#define AMO_ARMW_OR	 0x22
#define AMO_ARMW_AND	 0x23
#define AMO_ARMW_CAS_MAX_U	 0x24
#define AMO_ARMW_CAS_MAX_S	 0x25
#define AMO_ARMW_CAS_MIN_U	 0x26
#define AMO_ARMW_CAS_MIN_S	 0x27
#define AMO_ARMW_CAS_T	 0x38

#define DMA_DTYPE_RD_REQ	0x0
#define DMA_DTYPE_WR_REQ_128	0x1
#define DMA_DTYPE_WR_REQ_MORE	0x2
#define DMA_DTYPE_ATOMIC	0x3

#define DMA_SENT_UTAG_STS_RD	0x0
#define DMA_SENT_UTAG_STS_WR	0x1
#define DMA_SENT_UTAG_STS_FAIL	0x2
#define DMA_SENT_UTAG_STS_FLUSH	0x3

#define DMA_CPL_TYPE_RD_128	0x0
#define DMA_CPL_TYPE_RD_PLUS	0x1
#define DMA_CPL_TYPE_ERR	0x2
#define DMA_CPL_TYPE_POISON_B	0x3
#define DMA_CPL_TYPE_ATOMIC_RSP	0x4


/* Create one of these structures to interface to an AFU model and use the functions below to manipulate it */

/* *INDENT-OFF* */
struct AFU_EVENT {
  int sockfd;                         /* socket file descriptor */
  uint32_t proto_primary;             /* socket protocol version 1st number */
  uint32_t proto_secondary;           /* socket protocol version 2nd number */
  uint32_t proto_tertiary;            /* socket protocol version 3rd number */
  int clock;                          /* clock */
  unsigned char tbuf[TLX_BUFFER_SIZE];/* transmit buffer for socket communications */
  unsigned char rbuf[TLX_BUFFER_SIZE];/* receive buffer for socket communications */
  uint32_t rbp;                       /* receive buffer position */
  // job is no longer a tlx interface
  uint64_t job_address;               /* effective address of the work element descriptor */
  uint64_t job_error;                 /* error code for completed job */
  uint32_t job_valid;                 /* AFU event contains a valid job control command */
  uint32_t job_code;                  /* job control command code as documented in the TLX workbook */
  uint32_t job_running;               /* a job is running in the accelerator */
  uint32_t job_done;                  /* a job has completed in the accelerator */
  uint32_t job_cack_llcmd;            /* LLCMD command has been processed by AFU */
  uint32_t job_code_parity;           /* Odd parity for ha_jcom (job_code) valid with ha_jval (job_valid) */
  uint32_t job_address_parity;        /* Odd parity for ha_jea (job_address) valid with ha_jval (job_valid) */
  uint32_t job_yield;                 /* Used to save context in Shared mode. */
  uint32_t timebase_request;          /* Requests TLX to send a timebase control command with current timebase value. */
  uint32_t parity_enable;             /* If asserted, AFU supports parity generation on various interface buses. */
  // port mmio to some sort of partial read/write
  uint32_t mmio_address;              /* word address of the MMIO data to read/write */
  uint32_t mmio_address_parity;       /* Odd parity for MMIO address */
  uint64_t mmio_wdata;                /* write data for MMIO writes, unused if mmio_read is true */
  uint64_t mmio_wdata_parity;         /* Odd parity for MMIO write data */
  uint64_t mmio_rdata;                /* read data for MMIO reads */
  uint64_t mmio_rdata_parity;         /* Odd parity for MMIO read data */
  uint32_t mmio_valid;                /* AFU event contains a valid MMIO command */
  uint32_t mmio_read;                 /* MMIO command is a read type (otherwise it is a write type) */
  uint32_t mmio_double;               /* MMIO command is a 64-bit operation (otherwise read and write data should be limited to 32 bits) */
  uint32_t mmio_ack;                  /* MMIO command has been acknowledged */
  uint32_t mmio_afudescaccess;        /* MMIO command is access to AFU descriptor space */
  // port response to tlx_afu response stuff
  uint32_t response_valid;            /* AFU event contains a valid TLX response */
  uint32_t response_tag;              /* tag value from the command in the TLX_EVENT that is being responded to */
  uint32_t response_code;             /* response code for the command with tag value above as documented in the TLX workbook */
  int32_t credits;                    /* number of credits (positive or negative) to return to the AFU */
  // defer cache support to TLX4
  uint32_t cache_state;               /* cache state granted to the AFU as documented in the TLX workbook */
  uint32_t cache_position;            /* The cache position assigned by TLX */
  uint32_t response_tag_parity;       /* Odd parity for ha_rtag valid with ha_rvalid */
  uint32_t response_dma0_itag;        /* DMA translation tag for xlat_ *requests */
  uint32_t response_dma0_itag_parity; /* DMA translation tag parity   */
  uint32_t response_extra;            /* extra response information received from xlate logic */
  uint32_t response_r_pgsize;         /* command translated page size. values defined in CAIA2 workbook */
  // buffer reads are no longer driven from tlx.  rather they are driven complete from the afu as a write form of command
  uint32_t buffer_read;               /* AFU event contains a valid buffer read request */
  uint32_t buffer_read_tag;           /* tag from command in TLX_EVENT which requested the buffer read */
  uint32_t buffer_read_tag_parity;    /* Odd parity for buffer read tag */
  uint32_t buffer_read_address;       /* address within the transfer of the 64 byte chunk of data to read */
  uint32_t buffer_read_length;        /* length of transfer, must be either 64 or 128 bytes */
  uint32_t buffer_read_latency;       /* Read buffer latency in clocks */
  uint32_t buffer_write;              /* AFU event contains a valid buffer write request */
  uint32_t buffer_write_tag;          /* tag from command in TLX_EVENT which requested the buffer write */
  uint32_t buffer_write_tag_parity;   /* Odd parity for buffer write tag */
  uint32_t buffer_write_address;      /* address within the transfer of the 64 byte chunk of data to write */
  uint32_t buffer_write_length;       /* length of transfer, must be either 64 or 128 bytes */
  unsigned char buffer_wdata[128];    /* 128B data to write to the AFUs buffer (only first half used for 64B calls) */
  unsigned char buffer_wparity[2];    /* 128b parity for the write data (only first half used for 64B calls) */
  uint32_t buffer_rdata_valid;        /* buffer read data is valid */
  unsigned char buffer_rdata[128];    /* 128B data to read from the AFUs buffer (only first half used for 64B calls) */
  unsigned char buffer_rparity[2];    /* 128b parity for the read data (only first half used for 64B calls) */
  uint32_t aux1_change;               /* The value of one of the auxilliary signals has changed (room) */
  uint32_t room;                      /* the number of commands TLX has room to accept */
  uint64_t command_address;           /* effective address for commands requiring an address */
  uint64_t command_address_parity;    /* Odd parity for effective address for command */
  uint32_t command_valid;             /* AFU event contains a valid command */
  uint32_t command_tag;               /* tag associated with the command. used for buffer allocation and response matching */
  uint32_t command_tag_parity;        /* Odd parity for command tag */
  uint32_t command_code;              /* command code as documented in the TLX workbook */
  uint32_t command_code_parity;       /* Odd parity for command code */
  uint32_t command_size;              /* number of bytes for commands requiring transfer size */
  uint32_t command_abort;             /* indicates that the command may be aborted */
  uint32_t command_handle;            /* Context handle (Process Element ID) */
  uint32_t aux2_change;               /* The value of one of the auxilliary signals has changed (running, job done or error, read latency) */
  uint32_t command_cpagesize;	      /*  Page size hint used by TLX for predicting page size during ERAT lookup & paged xlation ordering..codes documented in TLX workbook tbl 1-1 */
  uint32_t dma0_dvalid;     	      /* DMA request from AFU is valid */
  uint32_t dma0_req_utag;	      /* DMA transaction request user transaction tag */
  uint32_t dma0_req_itag;     	      /* DMA transaction request user translation identifier */
  uint32_t dma0_req_type;	      /* DMA transaction request transaction type.  */
  uint32_t dma0_req_size;	      /* DMA transaction request transaction size in bytes */
  uint32_t dma0_atomic_op;	      /* Transaction request attribute - Atomic opcode */
  uint32_t dma0_atomic_le;	      /* Transaction request attribute - Little Endian used */
  uint32_t dma0_sent_utag_valid;      /* DMA request sent by TLX */
  uint32_t dma0_sent_utag;    	      /* DMA sent request indicates the UTAG of the request sent by TLX */
  uint32_t dma0_sent_utag_status;     /* DMA sent request indicates the status of the command that was sent by TLX. */
  uint32_t dma0_completion_valid;     /* DMA completion received  */
  uint32_t dma0_completion_utag;      /* DMA completion indicates the UTAG associated with the received completion data */
  uint32_t dma0_completion_type;      /* DMA completion indicates the type of response received with the current completion */
  uint32_t dma0_completion_size;      /* DMA completion indicates size of completion received */
  uint32_t dma0_completion_laddr;     /* DMA completion Atomic attribute - lower addr bits of rx cmpl */
  uint32_t dma0_completion_byte_count; /* DMA completion remaining amount of bytes required to complete originating read request
						including bytes being transferred in the current transaction   */
/* TODO must increase size of dma0_req_data & dma0_completion_data to 256 to be able to handle half of max DMA transfer in one socket transaction */
  unsigned char dma0_req_data[128];	      /* DMA data alignment is First byte first */
  unsigned char dma0_completion_data[128];  /* DMA completion data alignment is First Byte first */
  signed char dma0_wr_credits;	/* Used to limit # of outstanding DMA wr ops to MAX_DMA0_WR_CREDITS  */
  signed char dma0_rd_credits;	/* Used to limit # of outstanding DMA rd ops to MAX_DMA0_RD_CREDITS  */
  unsigned char dma0_rd_partial;;	/* Used to determine bc for DMA xfers > 128B  */
  unsigned char dma0_wr_partial;;	/* Used to determine bc for DMA xfers > 128B  */
};
/* *INDENT-ON* */

#endif
